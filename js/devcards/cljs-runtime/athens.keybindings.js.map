{"version":3,"sources":["athens/keybindings.cljs"],"mappings":"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","names":["athens.keybindings/modifier-keys","e","shift","meta","ctrl","alt","athens.keybindings/get-end-points","cljs.core.js__GT_clj.cljs$core$IFn$_invoke$arity$1","G__55801","goog.dom.selection/getEndPoints","athens.keybindings/destruct-event","vec__55802","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","key","key-code","target","value","event","modifiers","start","end","selection","goog.dom.selection/getText","head","cljs.core.subs.cljs$core$IFn$_invoke$arity$3","tail","cljs.core.subs.cljs$core$IFn$_invoke$arity$2","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","athens.keybindings/arrow-key?","map__55805","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","goog.events.KeyCodes/UP","goog.events.KeyCodes/LEFT","goog.events.KeyCodes/DOWN","goog.events.KeyCodes/RIGHT","athens.keybindings/block-start?","vec__55807","_","athens.keybindings/block-end?","map__55810","cljs.core/count","athens.keybindings/handle-arrow-key","uid","map__55812","top-row?","bottom-row?","G__55814","re-frame.core/dispatch","G__55815","G__55816","G__55817","athens.keybindings/handle-tab","map__55818","block-zero?","athens.db/get-block","G__55820","G__55821","athens.keybindings/handle-enter","state","map__55822","cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4","cljs.core/assoc","first","new-tail","new-head","new-str","G__55824","athens.keybindings/PAIR-CHARS","athens.keybindings/surround","around","temp__5733__auto__","complement","athens.keybindings/handle-system-shortcuts","map__55826","goog.events.KeyCodes/A","goog.dom.selection/setStart","goog.dom.selection/setEnd","goog.events.KeyCodes/Z","cljs.core.prn.cljs$core$IFn$_invoke$arity$variadic","goog.events.KeyCodes/X","goog.events.KeyCodes/V","goog.events.KeyCodes/B","goog.events.KeyCodes/I","athens.keybindings/pair-char?","map__55830","pair-char-set","cljs.core/seq","cljs.core/flatten","cljs.core/set","athens.keybindings/handle-pair-char","map__55832","close-pair","js/setTimeout","G__55834","G__55835","goog.dom.selection/setCursorPosition","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","surround-selection","G__55836","G__55837","G__55838","G__55839","four-char","cljs.core/deref","double-brackets?","double-parens?","athens.keybindings/handle-backspace","map__55841","possible-pair","G__55843","p1__55840#","cljs.core/some","G__55844","G__55845","map__55846","query","athens.keybindings/block-key-down","map__55848","goog.events.KeyCodes/TAB","goog.events.KeyCodes/ENTER","goog.events.KeyCodes/BACKSPACE","cljs.core/not","goog.events.KeyCodes/isCharacterKey","goog.events.KeyCodes/SLASH","or__4185__auto__"],"sourcesContent":["(ns athens.keybindings\n  (:require\n    [athens.db :as db]\n    [cljsjs.react]\n    [cljsjs.react.dom]\n    [goog.dom.selection :refer [setStart setEnd getText setCursorPosition getEndPoints]]\n    [goog.events.KeyCodes :refer [isCharacterKey]]\n    [re-frame.core :refer [dispatch]])\n  (:import\n    (goog.events\n      KeyCodes)))\n\n\n(defn modifier-keys\n  [e]\n  (let [shift (.. e -shiftKey)\n        meta (.. e -metaKey)\n        ctrl (.. e -ctrlKey)\n        alt (.. e -altKey)]\n    {:shift shift :meta meta :ctrl ctrl :alt alt}))\n\n\n(defn get-end-points\n  [e]\n  (js->clj (getEndPoints (.. e -target))))\n\n\n(defn destruct-event\n  [e]\n  (let [key (.. e -key)\n        key-code (.. e -keyCode)\n        target (.. e -target)\n        value (.. target -value)\n        event {:key key :key-code key-code :target target :value value}\n        modifiers (modifier-keys e)\n        [start end] (get-end-points e)\n        selection (getText target)\n        head (subs value 0 start)\n        tail (subs value end)]\n    (merge modifiers event\n           {:start start :end end}\n           {:head head :tail tail}\n           {:selection selection})))\n\n\n(defn arrow-key?\n  [e]\n  (let [{:keys [key-code]} (destruct-event e)]\n    (or (= key-code KeyCodes.UP)\n        (= key-code KeyCodes.LEFT)\n        (= key-code KeyCodes.DOWN)\n        (= key-code KeyCodes.RIGHT))))\n\n\n(defn block-start?\n  [e]\n  (let [[start _] (get-end-points e)]\n    (zero? start)))\n\n\n(defn block-end?\n  [e]\n  (let [{:keys [value end]} (destruct-event e)]\n    (= end (count value))))\n\n\n(defn handle-arrow-key\n  [e uid]\n  (let [{:keys [key-code]} (destruct-event e)\n        top-row?    true                                    ;; TODO\n        bottom-row? true]                                   ;; TODO\n    (cond\n      (and (= key-code KeyCodes.UP) top-row?)           (dispatch [:up uid])\n      (and (= key-code KeyCodes.LEFT) (block-start? e)) (dispatch [:left uid])\n      (and (= key-code KeyCodes.DOWN) bottom-row?)      (dispatch [:down uid])\n      (and (= key-code KeyCodes.RIGHT) (block-end? e))  (dispatch [:right uid]))))\n\n\n(defn handle-tab\n  [e uid]\n  (.. e preventDefault)\n  (let [{:keys [shift]} (destruct-event e)\n        ;; xxx: probably makes more sense to pass block value to handler directly\n        block-zero? (zero? (:block/order (db/get-block [:block/uid uid])))]\n    (cond\n      shift (dispatch [:unindent uid])\n      :else (when-not block-zero?\n              (dispatch [:indent uid])))))\n\n\n;;(defn cycle-todo\n;;  [])\n\n(defn handle-enter\n  [e uid state]\n  (let [{:keys [shift meta start head tail value]} (destruct-event e)]\n    (cond\n      ;; shift-enter: add line break to textarea\n      shift (swap! state assoc :atom-string (str head \"\\n\" tail))\n      ;; cmd-enter: toggle todo/done\n      meta (let [first    (subs value 0 12)\n                 new-tail (subs value 12)\n                 new-head (cond (= first \"{{[[TODO]]}}\") \"{{[[DONE]]}}\"\n                                (= first \"{{[[DONE]]}}\") \"\"\n                                :else \"{{[[TODO]]}} \")\n                 new-str  (str new-head new-tail)]\n             (swap! state assoc :atom-string new-str))\n      ;; default: may mutate blocks\n      :else (do (.. e preventDefault)\n                (dispatch [:enter uid value start state])))))\n\n\n;; todo: do this for ** and __\n(def PAIR-CHARS\n  {\"(\" \")\"\n   \"[\" \"]\"\n   \"{\" \"}\"\n   \"\\\"\" \"\\\"\"})\n  ;;\"`\" \"`\"\n  ;;\"*\" \"*\"\n   ;;\"_\" \"_\"})\n\n\n(defn surround\n  \"https://github.com/tpope/vim-surround\"\n  [selection around]\n  (if-let [complement (get PAIR-CHARS around)]\n    (str around selection complement)\n    (str around selection around)))\n\n\n;; TODO: it's ctrl for windows and linux right?\n(defn handle-system-shortcuts\n  \"Assumes meta is selected\"\n  [e _ state]\n  (let [{:keys [key-code target end selection]} (destruct-event e)]\n    (cond\n      (= key-code KeyCodes.A) (do (setStart target 0)\n                                  (setEnd target end))\n\n      ;; TODO: undo. conflicts with datascript undo\n      (= key-code KeyCodes.Z) (prn \"undo\")\n\n      ;; TODO: cut\n      (= key-code KeyCodes.X) (prn \"cut\")\n\n      ;; TODO: paste. magical\n      (= key-code KeyCodes.V) (prn \"paste\")\n\n      ;; TODO: bold\n      (= key-code KeyCodes.B) (let [new-str (surround selection \"**\")]\n                                (swap! state assoc :atom-string new-str))\n\n      ;; TODO: italicize\n      (= key-code KeyCodes.I) (let [new-str (surround selection \"__\")]\n                                (swap! state assoc :atom-string new-str)))))\n\n\n(defn pair-char?\n  [e]\n  (let [{:keys [key]} (destruct-event e)\n        pair-char-set (-> PAIR-CHARS\n                          seq\n                          flatten\n                          set)]\n    (pair-char-set key)))\n\n\n(defn handle-pair-char\n  [e _ state]\n  (let [{:keys [key head tail target start end selection]} (destruct-event e)\n        close-pair (get PAIR-CHARS key)]\n    (cond\n      (= start end) (let [new-str (str head key close-pair tail)]\n                      (js/setTimeout #(setCursorPosition target (inc start)) 10)\n                      (swap! state assoc :atom-string new-str))\n      (not= start end) (let [surround-selection (surround selection key)\n                             new-str (str head surround-selection tail)]\n                         (swap! state assoc :atom-string new-str)\n                         (js/setTimeout (fn []\n                                          (setStart target (inc start))\n                                          (setEnd target (inc end)))\n                                        10)))\n\n    ;; this is naive way to begin doing inline search. how to begin search with non-empty parens?\n    (let [four-char (subs (:atom-string @state) (dec start) (+ start 3))\n          double-brackets? (= \"[[]]\" four-char)\n          double-parens?   (= \"(())\" four-char)]\n      (cond\n        double-brackets? (swap! state assoc :search/page true)\n        double-parens? (swap! state assoc :search/block true)))))\n\n    ;; TODO: close bracket should not be created if it already exists\n    ;;(= key-code KeyCodes.CLOSE_SQUARE_BRACKET)\n\n\n\n(defn handle-backspace\n  [e uid state]\n  (let [{:keys [start end value head tail target meta]} (destruct-event e)\n        possible-pair (subs value (dec start) (inc start))]\n\n    (cond\n      ;; if selection, delete selected text\n      (not= start end) (let [new-tail (subs value end)\n                             new-str (str head new-tail)]\n                         (swap! state assoc :atom-string new-str))\n\n      ;; if meta, delete to start of line\n      meta (swap! state assoc :atom-string tail)\n\n      ;; if at block start, dispatch (requires context)\n      (block-start? e) (dispatch [:backspace uid value])\n\n      ;; if within brackets, delete close bracket as well\n      ;; todo: parameterize, use PAIR-CHARS\n      (some #(= possible-pair %) [\"[]\" \"{}\" \"()\"])\n      (let [head    (subs value 0 (dec start))\n            tail    (subs value (inc start))\n            new-str (str head tail)]\n        (swap! state assoc :atom-string new-str)\n        (swap! state assoc :search/page false)\n        (js/setTimeout #(setCursorPosition target (dec start)) 10))\n\n      ;; default backspace: delete a character\n      :else (let [head    (subs value 0 (dec start))\n                  new-str (str head tail)\n                  {:search/keys [query]} @state]\n              (cond\n                ;;(= (get value start) KeyCodes.SLASH)\n                ;;(swap! state update :slash? not)\n                query (swap! state assoc :search/query (subs query 0 (dec (count query)))))\n              (swap! state assoc :atom-string new-str)))))\n\n\n;; XXX: what happens here when we have multi-block selection? In this case we pass in `uids` instead of `uid`\n(defn block-key-down\n  [e uid state]\n  (let [{:keys [meta ctrl alt key key-code head tail]} (destruct-event e)]\n    (cond\n      (arrow-key? e) (handle-arrow-key e uid)\n      (pair-char? e) (handle-pair-char e uid state)\n      (= key-code KeyCodes.TAB) (handle-tab e uid)\n      (= key-code KeyCodes.ENTER) (handle-enter e uid state)\n      (= key-code KeyCodes.BACKSPACE) (handle-backspace e uid state)\n      meta (handle-system-shortcuts e uid state)\n      ;; -- Default: Add new character -----------------------------------------\n      (and (not meta) (not ctrl) (not alt) (isCharacterKey key-code))\n      (let [new-str (str head key tail)]\n        (cond\n          (= key-code KeyCodes.SLASH)\n          (swap! state assoc :slash? true)\n\n          (or (:search/page @state) (:search/block @state))\n          (swap! state assoc :search/query (str (:search/query @state) key)))\n        (swap! state assoc :atom-string new-str)))))\n\n;;:else (prn \"non-event\" key key-code))))\n\n"]}